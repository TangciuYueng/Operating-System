## 操作系统的发展历史
是一个从无到有的过程
$批处理 -> 分时系统 -> \begin{cases}
\text{大型机 并行 服务器端} \\
\text{在分时系统上继续发展 PC端桌面} \\
\text{小型机} \end{cases}$

### 简单批处理系统
- 一次做一个大作业(TASK)(粒度大)
- 做完之前不能修改
- 内存中只有 $   \begin{cases}
                \text{OS 调控程序，管理作业} \\
                \text{要执行的大作业} \end{cases}$
- OS只是调控的作用

### 多道程序批处理
- 硬件发展，CPU速度提升，我们一次交给CPU多个作业，让其充分工作
- 内存中只有 $   \begin{cases}
                \text{OS 的功能因此要求更复杂了} \\
                \text{大作业1} \\
                \text{大作业2} \\
                \text{大作业3} \end{cases}$
- 内存中有多个作业要求OS $\begin{cases}
                        \text{CPU管理：这几个作业怎么有序地做？做完A再B还是A一会B一会}\\
                        \text{内存管理：1. 分区保护，不能A做着做着就跑到B 2.虚拟内存管理，尽可能放更多的东西}\\
                        \text{外设管理：例如打印机(独占设备/排他设备)，一推作业如何有序使用该设备}\\
                        \end{cases}$
- 里程碑，但这时人机交互有问题，于是有了分时系统

### 分时系统
- 将两个大作业分成多个小作业，粒度小了，设置固定的**时间片**(要小要快->并发提升用户体验)
- 例如：$A.P_1$执行10ms，然后换成$B.P_2$执行10ms，

### 大型机 并行
- OS除了上述功能要实现，还要实现**任务划分**给多个结点
- 多个CPU共享内存，CPU算力相同就对称
  
### 小型机
- 嵌入式通常希望时间约束 -> 实时系统$  \begin{cases}
                                    \text{强/硬实时系统} \\
                                    \text{弱/软实时系统}
                                    \end{cases}$
- 强实时系统要求不管负载多重，在某时间之前一定要完成，否则时效性已过作业没有用，发生灾难
- 弱实时系统，不会发生灾难，但过了某个时间点效益迅速下降，因此也应该优先完成
  
### OS发展动力
- 被动发展
- 硬件、软件技术和应用需求推动
- 用户需求要求高性能和智慧性