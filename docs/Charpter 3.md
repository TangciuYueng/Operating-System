# 深入理解操作系统 第三章

>   第三章的主要内容是：操作系统的物理内存管理

## 计算机体系结构

1.  CPU
2.  内存
3.  I/O

## 内存分层体系

### 内存分层体系

运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.

CPU可以访问的内存包括两大类 : 寄存器 / cache(L1缓存 / L2缓存)

**层次**

微处理器(CPU访问)

|___CPU寄存器 / L1缓存

|___L2缓存

主存(程序访问)

磁盘(程序访问)

>   从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。

### 内存管理目标

*   抽象：逻辑地址空间

*   保护：独立地址空间

*   共享：访问相同内存

*   虚拟：更多的地址空间

### 内存管理方法

*   程序重定位
*   分段
*   分页
*   虚拟内存
*   按需分页虚拟内存

>   实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求

## 地址空间

地址空间的定义

*   物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] )
*   逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )

## 连续内存分配

### 内存碎片问题

内存碎片问题指的是空闲的内存无法被利用

*   外部碎片 : 分配单元间的未使用内存
*   内部碎片 : 分配单元内的未使用内存

### 分区的动态分配

分区的动态分配方式有以下三种 :

1.  第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序
2.  最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序
3.  最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序

分配方式的区别

| 分配方式         | 第一匹配分配                                                 | 最优适配分配                                                 | 最差适配分配                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分配方式实现需求 | 1. 按地址排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配最大的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 |
| 优势             | 简单 / 易于产生更大空闲块                                    | 比较简单 / 大部分分配是小尺寸时高效                          | 分配很快 / 大部分分配是中尺寸时高效                          |
| 劣势             | 产生外部碎片 / 不确定性                                      | 产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片             | 产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配 |

>   三种分配方式并无优劣之分，因为我们无法判断内存请求的大小

## 碎片整理方法

可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。

1.  压缩式碎片整理
    *   重置程序以合并碎片
    *   要求所有程序是动态可重置的
    *   问题 : 
        *   何时重置 ? (在程序处于等待状态时才可以重置)
        *   需要考虑内存拷贝的开销

2.  交换式碎片整理

    *   运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存

    *   问题 :

        *   哪些程序应该被回收 ?

    *   情况 :

        运行中 : P3

        等待中 : P1 P2 P4

        内存分布 -> 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空

        当P3程序需要更大的内存时 ->

        内存分布 -> 主存 : OS / P1 / P3 / P2         磁盘 : P4



