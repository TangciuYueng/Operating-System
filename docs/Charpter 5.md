# 深入理解操作系统 第五章

>   第五章的主要内容是：操作系统的虚拟内存管理技术

## 虚拟内存的起因

使用硬盘/磁盘使更多的程序在有限的内存中运行

理想的存储器 : 更大更快更便宜和非易失性的存储区

## 覆盖技术

如果是程序太大, 超出了内存的容量, 可以采用手动的概率(overlay)技术, 只把需要的指令和数据保存在内存当中

目的 : 是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用.

原理 :

把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行.

-   必要部分(常用功能)的代码和数据常驻内存;
-   可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存;
-   不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区.

>   也就是说,程序松耦合的部分可以按需装入内存,不需要的时候放在外存中,多个不常用部分共用一个分区.

实例 :

A(20k) ____B(50k) ____ D(30k)
        | ____ C(30k) ____ E(20k)
                             |____ F(40k)

因此不需要将整个程序190k的数据全部放入内存中, 而是划分为 常驻区(20k) 覆盖区0(50k) 覆盖区1(40k) 压缩至了110k的内存空间使用

缺点 :

-   由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度;
-   覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省.

## 交换技术

如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中

目的 : 多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源

原理 :

可将暂时不能运行的程序送到外存, 从而获得空闲内存空间. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间.

存在问题 :

-   交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出;
-   交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取
-   程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法

## 覆盖技术和交换技术的对比

特点 :

-   覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构.
-   交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构.
-   换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部.

在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :

-   覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担.
-   交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销.

## 虚拟内存管理技术

如果想要在有限容量的内存中, 以更小的页粒度为单位装入更多更大的程序, 可以采用自动的虚拟存储技术

-   目标

    像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉.

    像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换.

-   程序局部性原理

    程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域.

    -   时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内 ;
    -   空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内.

    程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果.

    实例 :

    ```cpp
    题目描述 :
    页面大小为4k, 分配给每个进程的物理页面是1. 
    在一个进程中, 定义了如下的二维数组 int A[1024][1024]. 该数组按行存放在内存, 每一行放在一个页面中.
    考虑一下程序的编写方法对缺页率的影响?
    
    程序编写方法1 : (发生了1024*1024次缺页中断)
    for(j = 0; j < 1024; j++)
    		for(i = 0; i < 1024; i++)
    				A[i][j] = 0;
    
    程序编写方法2 : (发生了1024次缺页中断)
    for(i = 0; i < 1024; i++)
    		for(j = 0; j < 1024; j++)
    				A[i][j] = 0;
    ```

-   基本概念

    可以在页式或段式内存管理的基础上实现

    -   在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行;
    -   在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序;
    -   另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段.

-   基本特征

    -   大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB.
    -   部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的;
    -   不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性.

-   虚拟页式内存管理

    页式内存管理

    页表 : 完成逻辑页到物理页帧的映射

    根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址.

    虚拟页式内存管理

    -   大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能.

    -   基本思路

        -   当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.
        -   在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行.

    -   页表表项

        逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号

        驻留位 : 表示该页是在内存中还是在外存.

        保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等

        修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存

        访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法.

    -   缺页中断处理过程 :

        1.  如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步;
        2.  采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存;
        3.  对q所对应的页表项修改, 把驻留位置为0;
        4.  将需要访问的页p装入到物理页面f当中;
        5.  修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f;
        6.  重新运行被中断是指令.

        >   在何处保存未被映射的页?
        >
        >   -   能够简单地识别在二级存储器中的页
        >   -   交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面

        后备存储(二级存储) :

        -   一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置
        -   代码段 : 映射到可执行二进制文件
        -   动态加载的共享库程序段 : 映射到动态调用的库文件
        -   其他段 : 可能被映射到交换文件(swap file)

    -   虚拟内存性能

        为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)

        EAT = 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率

        实例 :

        访存时间 : 10 ns

        磁盘访问时间 : 5 ms

        参数 p  = page fault 几率

        参数 q = dirty page 几率(对页面写操作)

        EAT = 10\*(1-p) + 5000000\*p\*(1+q)

